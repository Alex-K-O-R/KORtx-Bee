<?
use app\pages\Pages;

/**
 * @var app\pages\Page $this
 */
/**
 * @var app\WebUIApplication $App
 */
$App = $this->Application();
?>
<div class="content-wrapper">
        <div class="nav__tr">
            <ul class="tab-menu breadcrumbs">
                <li><a href="<?=Pages::main?>" class="breadcrumbs-link"><?=$App->Translater(array('RU'=>'Главная', 'EN'=>'Home'))?></a></li>
                <li><?=$App->Translater(array('RU'=>'О проекте KORtx', 'EN'=>'About KORtx'))?></li>
            </ul>
        </div>
        <br/>
    <div class="body">
        <div class="static">
            <div class="tab-content active col-lg-12 about-project">
                <div class="one-tr">
                    <h2>Вкратце.</h2>
                    <h3>Что за зверь такой?</h3>
                    <p>
                        KORtx Bee &mdash; KORtx <b>B</b>ack<b>e</b>nd <b>e</b>ngine &mdash; это удобный MVC-фреймворк для облегчения создания и портирования сайтов с перспективой автоматизации в части создания описаний моделей, <b>языковых и прочих функциональных моделей</b>, обращений к БД.
                    </p>
                    <p>
                        В основе идеологии лежит принципиальный отказ от гиперусложнения написания и поддержки кода, чем страдают некоторые популярные современные фреймворки.
                        Полагаю, каждый программист когда-то сталкивался с решениями, оставленными в наследство "выгоревшими-гуру-программерами", которые увязли, или уже ушли "загромождать" другие проекты,
                        поскольку не смогли справится с собственным творением из-за чрезмерного усложнения.
                        Подобные процессы не редкость, причины у них разные, а их наблюдение скорее расстраивает.
                    </p>
                    <p>
                        Такое положение дел вряд ли имеет отношение к прогрессу в IT. Скорее, к пробуксовыванию и деградации.
                    </p>
                    <p>
                        KORtx Bee построен с надеждой решить указанную проблему.
                    </p>
                    <p>
                        Как любой фреймворк, KORtx Bee предлагает определённую структуру и набор правил, которых следует придерживаться при развитии проекта.
                        Движок имеет чёткое разделение классов на страницы, темы, модели и контроллеры по направлениям, а также 5 основных директорий:
                        <ul>
                            <li>constants - важные "глобальные" константы, которые могут влиять на работу движка, либо "не привязаны" к конкретному классу;</li>
                            <li>core\dba\classes - главные механики доступа к базе данных;</li>
                            <li>core\dba\models - описания простых и диалект-зависимых моделей;</li>
                            <li>display\ - т.н. "виды". Css, js, темы, статические картинки, т.е. "клиентская сторона";</li>
                            <li>utilities\ - в зависимости от расположения директории, либо общие вспомогательные классы
                                (в т.ч. функции ядра), либо сторонние библиотеки которые могут пригодится где угодно.</li>
                        </ul>
                        KORtx Bee одинаково удобен и для быстрого создания компактного веб-приложения (например, для одноплатных компьютеров), и для реализации гораздо более крупных сложных решений с функциями API.
                        Подобным разделением на серверную и клиентскую части вряд ли может похвастать любой из существующих фреймворков.
                    </p>
                    <h2>Подробно.</h2>
                    <h3>Основы.</h3>
                    <p>
                        Типовой проект на KORtx Bee &mdash; это Интерфейс (веб, или программный), построенный наследованием от корневого класса Application.
                        Класс Application является ядром и предоставляет иснтрументарий для работы с сессиями, страницами и их свойствами, обработки запросов и многое другое.
                    </p>
                    <p>
                        Для примера, этот демо-сайт представлен в файле WebUI.php, который обеспечивает основную механику и выглядит как сосредоточие
                        всех контроллеров (список кейсов вида case Pages::main).
                        Каждый кейс &mdash; в данном случае суть контроллер в MVC. В большинстве случаев при написании приложения изменяется именно эта часть. В зависимости от сложности проекта,
                        контроллеры можно дробить/группировать на геттеры, инклюды, трейты, либо отдельные классы, унаследованные от того же Application.
                    </p>
                    <p>
                        Указанные контроллеры напрямую связаны с системой адресов, которая описывается в сегменте
                        app\pages\Pages. Константами в указанном классе заданы маски url, которые используются в контроллерах WebUI.php в данном примере.
                        Таким образом, уже просматривается типовая схема создания новой страницы:
                        <ul>
                        <li>1. Придумывается маска url;</li>
                        <li>2. В WebUI добавляется кейс по маске;</li>
                        <li>3. В кейсе происходит подготовка/обработка данных, далее всё выводится на вид примерно так:<br/>
                            $this -> Page() -> UseTheme('cool-one') -> Display('/service/additionals/index.php');</li>
                        </ul>
                        Наглядно представлено в case Pages::user_info: { ... } в WebUI.php &mdash; страница отображения информации о пользователе.
                    </p>
                    <h3>Реализация моделей.</h3>
                    <p>
                        Исходя из принципа MVC, для связи V и C используется M, то есть модель для передачи данных.
                        Модели доступны в пространстве имён app\models. Согласно заданного в KORtx Bee порядка, все модели делятся на диалект-зависимые (построенные на базе DynamicsModelContainer)
                        и независимые от системного языка сущности. Диалект-зависимые модели – это те модели, которые содержат хотя бы одно диалект-зависимое поле, т.е. поле, содержание которого может меняться при смене пользователем языка сайта.
                        Тип модели с учётом пространства имён выбирается исходя из конкретной задачи.
                        Для порядка предлагается всем названия классов моделей добавлять суффикс MDL в название.
                    </p>
                    <p>
                        Существующие модели представлены в директориях core/models/.
                    </p>
                    <p>
                        99% методов в моделях &mdash; это геттеры, которые есть у экземпляра объекта и позволяют получить всю информацию, которую содержит модель. Иногда эти геттеры имеют минимальную обёртку для удобства (например, геттер с параметром возвращаемого формата даты).
                        Какие-то методы, кроме получения полей, либо улучшения юзабилити при работе с моделью создавать не следует, т.к. это ПРЯМО ПРОТИВОРЕЧИТ ПРИНЦИПУ MVC И ВЕДЁТ К БАРДАКУ.
                    </p>
                    <h3>Реализация языковой модели.</h3>
                    <p>
                        В KORtx Bee по умолчанию действует языковая модель. Она распространяется на динамический и статический контексты.
                        К динамическому контексту относятся сущности с диалект-зависимыми полями, которые могут подвергаться неконтроллируемому изменению
                        участниками системы. Например, у пользователя (модель UserMDL) может быть поле информации о себе, содержание которого разное для разных языков и может меняться по инициативе пользователя.
                        К статическому контексту относится содержание веб-страниц, которое не меняется пользователями.
                    </p>
                    <p>
                        Динамический сегмент оперирует в работе идентификатором языка и генерируется Процессором моделей. Язык соответствует записи в таблице *_languages в БД, а также глобальному фильтру окружения Application->getGlobalFilter()->getPortalLanguageInfo().
                    </p>
                    <p>
                        Статический сегмент оперирует в работе акронимом языка и на выбор: массивами переводов, либо страницами с детерминированной языковой принадлежностью.
                    </p>
                    <h4>Динамический сегмент и диалект-зависимые модели</h4>
                    <p>
                        Все диалект-зависимые модели являются производными от класса динамического контейнера DynamicsModelContainer и строятся по определённому принципу для дальнейшего использования препроцессором ModelProcessor.
                    </p>
                    <p>
                        Объект динамического контейнера нужен для "подсветки" полей, зависящих от языка. "Подсветка" осуществляется заданием массива индексов в классе-описателе, которые соответствуют:
                        <ul>
                            <li>расположению поля по порядку в результате получения данных из БД;</li>
                            <li>расположению поля в конструкторе модели.</li>
                        </ul>
                    При этом действует ограничение: порядок следования полей в конструкторе после задания индексов ДОПУСКАЕТСЯ МЕНЯТЬ ТОЛЬКО С УЧЁТОМ ИНДЕКСОВ! Иначе вместо нужного текста будет выводится, или изменяться какое-то соседнее поле.
                    </p>
                    <p>
                        Общий принцип создания диалект-зависимой модели:
                        <ul>
                            <li>определение необходимых полей в БД (рекомендуется отмечать диалект-зависимые поля префиксом d_*);</li>
                            <li>создание общей DBA-функции для получения основных полей (см. использование интерфейса IModelDataProvider), участвующих в построении модели с перечислением этих полей (Внимание! Без селектора "*".);</li>
                            <li>описание полей модели в классе;</li>
                            <li>объявление конструктора с учётом порядка следования полей в результате запроса из БД;</li>
                            <li>перечисление индексов полей, зависящих от языка, в части DynamicsModelContainer.</li>
                        </ul>
                        Пример описания диалект-зависимой модели &mdash; это сущность UserMDL, контент для которой достаётся общим SQL-запросом из UserDBA, обеспечивающим сопоставления порядка следования полей в конструкторе и описателе DynamicsModelContainer.
                    </p>
                    <p>
                        Описание вызова препроцессора для получения итоговой модели, сформированной с учётом языка приведён ниже:<br/>
                        $USERS = ModelProcessor::loadModelsForLanguage(<br/>
                            <ul>
                            <li>UserMDL::TYPE(), // тип возвращаемых препроцессором моделей</li>
                            <li>$UserList = $this->getUserDBA()->getUsersInfo...(), // получение массива исходных данных</li>
                            <li>$this->getUserDBA(), // провайдер dba, использующийся для получения данных (в общем может отличаться от основного)</li>
                            <li>$this->getGlobalFilter()->getPortalLanguageInfo()->getLangId() // идентификатор языка, для которого формируется итоговая модель</li>
                            </ul>
                        );
                    </p>
                    <h4>Статический сегмент и возможности приложения Application</h4>
                    <p>
                        Статический сегмент представляет собой содержимое веб-страниц, которое изменяется в зависимости от выбранного языка, но не имеет вариативности кроме той, которую
                        определили создатели сайта. Например, ссылки в меню сайта, общий заголовок каталога, название поля формы и т.п. Как сообщалось ранее, статический сегмент оперирует в работе акронимом языка,
                        а также двумя возможностями, "заложенными" в ядре KORtx Bee: массивами переводов, либо страницами с детерминированной языковой принадлежностью.
                    </p>
                    <p>
                        Первый вариант предполагает использование в том случае, когда лишь небольшая часть информационных блоков в отображении зависит от языка.
                        У любого интерфейса, построенного на основе класса Application, доступен метод Application->Translater, куда следует передать пары ключ-значение для существующих в системе языков.
                        Выглядит следующим образом:<br/>
                        < ? =$App->Translater(array('RU'=>'Новости', 'EN'=>'Latest news')) ? >
                    </p>
                    <p>
                        Второй вариант используется, если объёмная часть текста на странице привязана к языку, либо есть необходимость сделать разные акценты на странице, в зависимости от культурных основ посетителя сайта.
                        Примерами могут служить разделы, рассказывающие об истории конкретной компании, тексты посвящённые документированию функций API/частей веб-сервиса вроде того, что сейчас читаете.
                        В этом случае массивами-вставками пользоваться неудобно и на помощь приходят страницы, или виды с заданной языковой принадлежностью.
                    </p>
                    <p>
                        Фреймворк KORtx Bee для отображения использует т.н. "виды", т.е. файлы веб-страниц сайта, которые содержат информационную часть за вычетом общих и тематических элементов сайта: "заголовоков" и "подвалов",
                        специальных блоков меню, доступных много где и прочих подобных элементов отрисовки. Обычно каждый вид находится в отдельной отведённой для него директории в общем каталоге страниц, например:
                        /pages/about/index.php. Указанный файл index.php с телом страницы будет загружен <b>по умолчанию</b>, в случае указания ссылки на него из любого контроллера.
                    </p>
                    <p>
                        Однако, предусмотрена возможность размещения дополнительных видов в субкаталогах, соответствующих акронимам языка, относительно основного вида.
                        Например, вид, который обеспечивает читаемый вами текст имеет следующую структуру:
                        /pages/about/
                            EN/index.php - читаемый текст на английском (необяз.)
                            RU/index.php - читаемый текст на русском (необяз.)
                            index.php - вид по умолчанию с информацией об отсутствии перевода, который будет отображаться, если завтра в системе появится и будет выбран ещё один язык.

                    </p>
                    <h3>Реализация видов.</h3>
                    <p>
                        Всё, что относится к отображению (т.е. всё, что предназначено для клиентской стороны) располагается в разделе display, имеющем вложенные каталоги для простого и понятного разделения на направления: css, img, js, ...
                    </p>
                    <p>
                        Особое внимание следует уделить перечисленным папкам:
                        <ul>
                        <li>general - там описываются темы, а также общие шаблоны, например, заголовка и подвала;</li>
                        <li>nodes - в ней сосредоточены повторяющиеся модульные элементы, завязанные на php и js: меню, редакторы;</li>
                        <li>pages - директория, содержащая в себе страницы/виды, использующиеся в контроллерах.</li>
                        </ul>
                    </p>
                    <p>
                        В теле любого вида исходя из контекста в указателе $this доступен объект Page (страница). Страница имеет удобный в обращении инструментарий: хранилище переменных, поле состояния, описатели заголовков. Через свойства Page можно попасть также на уровень самого приложения Application.
                        Примеров работы с объектом Page достаточно даже в демонстрационном сайте.
                    </p>
                    <h3>Структура каталогов.</h3>
                    <p>
                        Закрепим структуру файлов и каталогов.
                    </p>
                    <p>
                        В корне сайта обычно находятся от 4-ёх файлов:
                        <ul>
                            <li>.htaccess - настроен под нужды движка и традиционные правила SEO;</li>
                            <li>index.php - является прокси для возможности работы нескольких приложений, например общедоступного веб-сервиса и раздела API, в зависимости от присутствия субдомена api.* в исходном запросе;</li>
                            <li>Loader.php - загрузчик основных библиотек фреймворка KORtx Bee для одного, или нескольких приложений;</li>
                            <li>WebUI.php / API.php / AdminUI.php - контроллер одного, или нескольких интерфейсов, который подключается в index.php</li>
                        </ul>
                    </p>
                    <p>
                        Из "основных" директорий доступны каталоги, чьё описание приведено в кратком описании движка выше. Продублируем:
                        <ul>
                            <li>constants - важные "глобальные" константы, которые могут влиять на работу движка, либо "не привязаны" к конкретному классу;</li>
                            <li>core\dba\classes - главные механики доступа к базе данных;</li>
                            <li>core\dba\models - описания простых и диалект-зависимых моделей, которые используются повсеместно;</li>
                            <li>display\ - т.н. "виды". Css, js, темы, статические картинки, т.е. "клиентская" сторона;</li>
                            <li>utilities\ - в зависимости от расположения директории, либо общие вспомогательные классы
                                (в т.ч. функции ядра), либо сторонние библиотеки которые могут пригодится где угодно.</li>
                        </ul>
                    </p>
                    <h3>Взаимодействие с базой данных.</h3>
                    <p>
                        Для взаимодействия с базой данных в системе используются типизированные объекты доступа. Все они находятся в директории /core/dba/, выделяются суффиксом DBA и имеют общего предка DBAccess.
                    </p>
                    <p>
                        Часто используемые объекты доступа к БД могут инициализироваться вместе с приложением, другие создаются в контроллерах по требованию. Тут всё достаточно просто.
                    </p>
                    <p>
                        Во всех провайдерах DBA, унаследованных от DBAccess есть метод ...DBA->query(). Первым параметром идёт SQL-запрос, вторым &mdash; тип возвращаемого результата.
                        Чаще всего приходится использовать возвращаемые типы 'row' и 'arr' (подходят для ModelProcessor'а). Главное, всегда помнить в дальнейшей работе, чего именно получали: если передавался 'row', то вернётся "объект"; если 'arr', то массив "объектов".
                    </p>
                    <p>
                        Доставание исходной информации осуществляется методом c логичным названием из подходящего объекта DBA. Внимание! Обращение за получением информации об объекте
                        ВСЕГДА ДОЛЖНО БЫТЬ ПОСТРОЕНО "ВОКРУГ" БАЗОВОГО SQL-запроса, СОДЕРЖАЩЕГО ИСЧЕРПЫВАЮЩИЙ ПЕРЕЧЕНЬ ПОЛУЧАЕМЫХ ПОЛЕЙ.
                        Для этого всегда рекомендуется описывать провайдер доступа к БД из интерфейса IModelDataProvider &mdash; он "принуждает" реализовывать подобный запрос.
                        Такой подход позволяет в полной мере использовать возможности ядра KORtx Bee и гарантированно упростит автоматизацию и поддержку в будущем.
                    </p>
                    <p>
                        Для диалект-зависимых полей реализован общий метод для удобства их изменения. Поскольку метод подразумевает передачу типа сущности, сочтено уместным его тиражирование в типизированные DBA копированием. Впрочем, ничего не мешает выделить этот метод в отдельного предка.
                    </p>
                    <h3>Журналирование, отладка, профилирование.</h3>
                    <p>
                        KORtx Bee имеет некоторые встроенные возможности по профилированию и отладке. Включение/отключение осуществляется в настоящее время из интерфейса ICoreSettings, путём изменений значений констант.
                    </p>
                    <p>
                        Отладочные журналы (логируются ошибки SQL и самого приложения) представляют собой текстовые файлы с детальной информацией для поиска и устранения неполадок. Результаты профилирования также попадают в отдельный текстовый файл. По умолчанию замерщик создаёт запись
                        только по превышению аварийной уставки на этапах подготовки данных и формирования страницы. Уставка задаётся при инициализации класса Profiler; инициализация происходит автоматически на этапе загрузки веб-приложения Application.
                    </p>
                    <p>
                        Кроме отладки, доступны также журналы изменений, включающие информацию о времени изменений, об идентификаторе целевого объекта, источнике изменений, описания изменений.
                    </p>
                    <p>
                        В KORtx Bee предусмотрено 2 вида журналирования, которые обеспечивает класс LogDBA: с контекстом изменений (когда пользователь работает с определённой сущностью) и без него (работает сценарий).
                    </p>
                    <p>
                        Контекст изменений обеспечивается экземпляром DBModificationContext, который может передаваться в метод LogDBA, а также корректироваться для конкретной сущности в случае пакетных изменений.
                    </p>
                    <p>
                        Записи журналов попадают в базу данных, по умолчанию &mdash; в общую. Эти записи обязательно имеют уровень значимости, который определяется в конкретном методе изменения поля в DBA.
                        Различные уровни в перспективе легко позволят организовать различные интервалы хранения данных для значимых и менее интересных записях об изменениях в случаях ручного, или автоматического очищения журналов.
                    </p>
                    <h3>Итого.</h3>
                    <p>
                        Если вы читаете этот абзац, значит вы уже получили представление о работе фреймворка KORtx Bee и можете попробовать реализовать что-то. Например, новую страницу с традиционным "Hello World!".
                        А может быть, сразу более серьёзное &mdash; новую модель и её провайдер.. В любом случае, желаю успехов!
                    </p>
                </div>
            </div>
        </div>
    </div>
</div>